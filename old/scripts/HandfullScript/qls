#!/usr/bin/perl
use Time::Local;
use strict;
use warnings;

##############################################################################
# Script collects essential information from Sun Grid Engine 6 and dumps it  #
# onto screen in a user-friendly format :)                                   #
# Author:  Alexey Dick (dick@mpie.de)                                        #
##############################################################################`

sub getQueues           ( );
sub getComplexSetup     ( );
sub getQueuesSetup      ( );
sub getQueuesSummary    ( );
sub getJobsSetup        ($);
sub getHostJobsSetup    ($);
sub getHostsSetup       ( );
sub filterJobs          ($$);
sub split2SeqParJobs    ($);
sub toEpochTime         ($$);
sub toKb                ($);
sub toGb                ($);
sub toSec               ($);
sub printQueues         ( );
sub printRunning        ($);
sub printAverageWTime   (%);
sub printNodes          ($);
sub printUsers          ($);
sub printProjects       ( );
sub printWaiting        (%);
sub printStatistics     ( );
sub printSynopsis       ( );
sub printHelp           ( );
sub printVersion        ( );
sub round               ($);
sub nextItem            ($$);
sub seconds2dhm         ($);
sub cutString           ($$$);
sub isOddNumber         ($);
sub printHint           ($);
sub centerString        ($$);
sub getQueueName        ($$);
sub getQueueAttributeMap($);
sub printHeader         ($);
sub printFooter         ($);
sub checkErrors         ($$);

# --- Global variable that contains list of all users in the system
#my $allUsers = "";

##############################################################################
# --- PARSE COMMAND LINE
if ($#ARGV > -1)  {
  my (@users, @options, $optionsList, $usersList);
  $usersList = ""; $optionsList = "";
  for (my $i=0; $i <= $#ARGV; $i++)  {
     if ($ARGV[$i] =~ /^-/)  { # option(s) 
        $optionsList .= $ARGV[$i];
     }  else  {                # user(s) 
        $usersList   .= "-u ".$ARGV[$i]." ";
     }
  }
  if ($usersList eq "")  { $usersList = "-u \"*\""; }
  if (length($optionsList) == 0)  {
     printSynopsis();
  }  else  {
#if ($optionsList =~ /w|ws|wp|r|n|u|i/)  {
#        $allUsers = `ypcat passwd | awk -F ':' '{print \$1}' | xargs`;
#        chomp($allUsers); $allUsers .= " root";
#     }
#     if ($optionsList =~ /ws/)  { 
#        printWaiting ({printUsers=>$usersList, jobsType=>['serial']}); 
#        $optionsList =~ s/ws//g; 
#     }
#     if ($optionsList =~ /wp/)  { 
#        printWaiting ({printUsers=>$usersList, jobsType=>['parallel']}); 
#        $optionsList =~ s/wp//g; 
#     } 
     if ($optionsList =~ /w/)   { 
        printWaiting ({printUsers=>$usersList, jobsType=>['serial',
                                                          'parallel']}); 
        $optionsList =~ s/w//g; 
     }
     if ($optionsList =~ /t/)   { 
        printAverageWTime ({printUsers=>$usersList, jobsType=>['serial',
                                                          'parallel']}); 
        $optionsList =~ s/t//g; 
     }

     if ($optionsList =~  /q/)  { printQueues     ( );          
                                  $optionsList =~ s/q//g;  }
     if ($optionsList =~  /r/)  { printRunning    ($usersList); 
                                  $optionsList =~ s/r//g;  }
    if ($optionsList =~  /n/)  { printNodes      ($usersList); 
                                  $optionsList =~ s/n//g;  }
     if ($optionsList =~  /u/)  { printUsers      ($usersList); 
                                  $optionsList =~ s/u//g;  }
     if ($optionsList =~  /p/)  { printProjects   ( );         
                                  $optionsList =~ s/p//g;  }
#     if ($optionsList =~  /i/)  { printStatistics ( );          
#                                  $optionsList =~ s/i//g;  } 
     if ($optionsList =~  /h/)  { printHelp       ( );          
                                  $optionsList =~ s/h//g;  }
     if ($optionsList =~  /v/)  { printVersion    ( );          
                                  $optionsList =~ s/v//g;  }
     if ($optionsList =~  /-+[a-zA-Z]+/)  {
        my @exeFullPath = split(/\//,$0);
        my $exe = $exeFullPath[$#exeFullPath];
        $optionsList =~ s/-+//;
        printf("\nSorry, option \"$optionsList\" is unknown.\n");
        printf("Please type '$exe' or '$exe -h' to see complete");
        printf(" list of available options.\n");
        exit; 
     }
  }
}  else  {
   printSynopsis();
}
printf("\n");  

# --- END PARSE COMMAND LINE
##############################################################################




##############################################################################
# Subroutines                                                                #
##############################################################################


##############################################################################
# --- print syntaxis
sub printSynopsis()  {
  my @exeFullPath = split(/\//,$0);
  my $exe = $exeFullPath[$#exeFullPath];
  printf("SYNOPSIS\n");
  printf("        $exe [OPTION] [USER]\n\n");
  printf("DESCRIPTION\n");
  printf("        Collects essential information provided by\n");
  printf("        SGE 6.2 and prints it in a user-friendly format\n\n");
  printf("        Mandatory argument(s) [OPTION]:\n");
  printf("        -u\n");
  printf("             view cumulative information about user jobs\n");
  printf("        -t\n");
  printf("             view average waiting times for users\n");
  printf("        -r\n");
  printf("             view detailed information about running jobs\n");
  printf("             Notes: Prefix \"\~\" in the queue field indicates the\n");
  printf("                    slave parallel job.\n");
  printf("                    Prefix \"\*\" in the queue field indicates that\n");
  printf("                    a serial job occupies entire node\n");
#  printf("        -n\n");
#  printf("             view nodes information\n");
#  printf("             Notes: Prefix \"\~\" in the queue field indicates the\n");
#  printf("                    slave parallel job.\n");
#  printf("                    Prefix \"\*\" in the queue field indicates that\n");
#  printf("                    a serial job occupies over entire node\n");
  printf("        -q\n");
  printf("             view cumulative queues information\n");
#  printf("        -i\n");
#  printf("             view cumulative cluster information\n");
  printf("        -p\n");
  printf("             view cluster consumption basing on projects structures\n");
  printf("        -w\n");
  printf("             view information about all waiting(queued) jobs\n");
#  printf("        -ws\n");
#  printf("             view information about serial waiting(queued) jobs\n");
#  printf("        -wp\n");
#  printf("             view information about parallel waiting(queued) jobs\n");
  printf("        -h\n");
  printf("             print help\n\n");
  printf("        -v\n");
  printf("             print version\n\n");
  printf("        Auxiliary argument(s) [USER]:\n");
  printf("        uid\n");
  printf("             print information for user(s) with specified\n");
  printf("             uid(s) only\n\n");
}
# --- end print syntaxis
##############################################################################


##############################################################################
# --- print help
sub printHelp()  {
  my @exeFullPath = split(/\//,$0);
  my $exe = $exeFullPath[$#exeFullPath];
  printf("\nNAME\n");
  printf("        $exe - list queue information\n\n");
  printSynopsis();    
  printf("EXAMPLES\n");
  printf("        $exe -r\n");
  printf("              print information about running jobs\n\n");
  printf("        $exe -r uid\n");
  printf("              print information for running jobs\n");
  printf("              that belong to user \"uid\"\n\n");
  printf("        $exe -qn\n");
  printf("              print queue and node information\n\n");
  printf("        $exe -w uid\n");
  printf("              print information about waiting(queued) jobs for\n");
  printf("              user \"uid\"\n\n");
#  printf("        $exe -ws\n");
#  printf("              print information about serial waiting(queued) jobs\n\n");
#  printf("        $exe -wp uid\n");
#  printf("              print information about parallel waiting(queued) jobs for\n");
#  printf("              user \"uid\"\n\n");
  printf("        $exe -w uid1 uid2 uid3\n");
  printf("              print information about waiting(queued) jobs for\n");
  printf("              users \"uid1\", \"uid2\" and \"uid3\"\n\n");
#  printf("        $exe -i\n");
#  printf("              print cumulative cluster information\n\n");
  printf("        $exe -p\n");
  printf("              print consumption information on project-basis\n\n");
  printf("        $exe -irw uid\n");
  printf("              print cumulative cluster information together with\n");
  printf("              report on running and waiting(queued) of user \"uid\"\n\n");
  printf("VERSION\n        ");
  printVersion();
  printf("\n\nAUTHOR\n");
  printf("        Alexey Dick \(dick\@mpie.de\)\n");
}
# --- end print help
##############################################################################

##############################################################################
# --- print version
sub printVersion()  {
   printf("v. 1.41, August 16 2011");
}
# --- end print version
##############################################################################

##############################################################################
# --- print nodes information 
sub printRunning($)  {

   my $usersList  = shift;

   my ($jobsSetup,$hostsSetup) = getHostJobsSetup ($usersList);
   my $detailedJobsSetup       = 
      filterJobs("running",getJobsSetup($usersList));
   my $queueAttributeMap       = getQueueAttributeMap(getQueuesSetup());
  
   my $localTime   = time();

   my $body = "";
   foreach my $node (sort keys %$hostsSetup)  {
      if (exists $jobsSetup->{$node})  {
         foreach my $iJob (sort keys %{$jobsSetup->{$node}})  {
            
            my $jobID = $jobsSetup->{$node}{$iJob}{"jobID"};
            
            if (exists $detailedJobsSetup->{$jobID})  {
            
               my $job   = \%{$detailedJobsSetup->{$jobID}};

               my ($queueName,$mute) = getQueueName($job,$queueAttributeMap);
               $queueName = $jobsSetup->{$node}{$iJob}{"type"} eq "MASTER" ? 
                            $queueName : "~".$queueName;

               my $waitTime = seconds2dhm ($localTime - 
                              toEpochTime($job->{"date"},$job->{"time"}));

               $body .= sprintf("%16s ", 
                        centerString($hostsSetup->{$node}{"LOAD"} eq "-" 
                        ? $node."(down)" : $node,14));
               $body .= sprintf("%22s ", 
                        cutString($job->{"Full jobname:"},22,5));
               $body .= sprintf("%22s",  $job->{"user"}."(".$queueName.")");
               $body .= sprintf("%12s",  $waitTime);
               $body .= sprintf("%11s\n",$jobID);
            }
         }
      }
   } 


   if (length($body) > 0)  {
      printHeader("running_detailed");
      print($body);
      printFooter("running_detailed");
   }  else  {
      print("\n  No running jobs");
   }
}
# --- end print nodes information
##############################################################################

##############################################################################
# --- print nodes information 
sub printStatistics()  {
  
  print ("WARNING! Statistics could be wrong (known but unsolved bugs)\n"); 
   
  # --- my info-containers 
  my %userHosts;  my %hostUsers;
  my %userQueues; my %queueUsers;
  my %hostLoad;   my %hostMemory;
  my %users;      my %jobState;   
  my $userList;   my %hostCPUs;


  # --- check if we can execute the queue command
  my $path = `which qhost 2> /dev/null`; chomp($path);
  if (!-x "$path")  {
     print ("Cannot execute 'qhost' command. ");
     print ("Check your PATH variable and/or whether SGE is up.\n");
     exit;
  } 

  # --- check if we can execute the queue command
  $path = `which qstat 2> /dev/null`; chomp($path);
  if (!-x "$path")  {
     print("Cannot execute 'qstat' command. ");
     print("Check your PATH variable and/or whether SGE is up.\n");
     exit;
  }

  # --- dump queue information
  my $dump = `qhost -j`;
  my @line = split(/\n/, $dump);

  # --- parse dump
  my @string; my @subString;
  my ($nCPU, $load, $memTot, $memUsed, $relLoad, $relMem);
  my ($uid, $queue, $master, $host);
  for (my $i=3; $i <= $#line; $i++)  {  
    @string = split(/\s+/,$line[$i]);
    for ($#string)  {
      # empty node description
      if (/7/)  {
        $host              = $string[0];
        $nCPU              = $string[2];
        $load              = $string[3];
        $string[4]         =~ m/(\d+.\d)(\D)/; 
        $memTot            = $2 eq "G" ? 1024 * $1 : $1;
        $string[5]         =~ m/(\d+.\d)(\D)/; 
        $memUsed           = $2 eq "G" ? 1024 * $1 : $1;
        $relLoad           = $load eq "-" ? "-" : int 100 * $load/$nCPU;
        $hostLoad{$host}   = $relLoad . "%";
        $relMem            = $load eq "-" ? "-" : int 100 * $memUsed/$memTot;
        $hostMemory{$host} = $relMem . "%";
        $hostUsers{$host}  = " "; 
        $hostCPUs{$host}   = $nCPU;
      } 
      # jobs description
      elsif (/9/)  {
        $uid                 = $string[4];
        @subString           = split(/\@/,$string[8]);   
        $queue               = $subString[0];
        $master              = $string[9] eq "MASTER" ? "" : "~";
        $userHosts{$uid}    .= " ".$host;
        $hostUsers{$host}   .= " ".$uid."(".$master.$queue.")";
        $userQueues{$uid}   .= " ".$queue;
        $queueUsers{$queue} .= " ".$uid;
      }
      # parallel jobs
      elsif (/2/)  {    
        @subString         = split(/\@/,$string[1]);   
        $queue             = $subString[0];
        $master            = $string[2] eq "MASTER" ? "" : "~";
        $hostUsers{$host} .= " ".$uid."(".$master.$queue.")";
        $userHosts{$uid}  .= " ".$host;
      }
    }
  }
  
  # --- check if we have running jobs at all
  my $haveJobs = 0;
  if (length(%queueUsers) != 0)  {
     $haveJobs = 1;
  }
    
  my @userQueue; 
  # --- print information for all users if required
  if ($haveJobs)  {
     my $sumLoad    = 0; 
     my $sumMemory  = 0;
     my $nAllCPU    = 0; 
     my $nUsedCPU   = 0;
     my $nDownCPU   = 0;
     my $nNodesUp   = 0;
     my $nNodesDown = 0;
     my $nNodesSusp = 0;
     foreach $host (sort keys %hostUsers)  {
        @userQueue = split(/\s+/,$hostUsers{$host});
        # --- check if host is ok and if not mark it
        if ($hostMemory{$host} eq "0%" ||
           ($hostLoad{$host}   eq "0%" && $#userQueue > 0))  {
           $nNodesSusp++;
        } 
        if ($hostMemory{$host} eq "-%")  {
           $nDownCPU += $hostCPUs{$host};
           $nNodesDown++;
        }  else  {
           $sumLoad   += substr($hostLoad{$host},  0,-1); 
           $sumMemory += substr($hostMemory{$host},0,-1); 
           $nNodesUp++;
#  $nAllCPU   += $hostCPUs{$host};
           for (my $i=1; $i <= $#userQueue; $i++)  {
              $nUsedCPU++;
           }
        }
        $nAllCPU += $hostCPUs{$host};
     }
     my $nFreeCPU     = $nAllCPU - $nUsedCPU - $nDownCPU;
     my $nNodesAll    = $nNodesUp + $nNodesDown;
     my $clusterUsage = round(100 * $nUsedCPU / ($nAllCPU-$nDownCPU));
     my $clusterIdle  = 100 - $clusterUsage;
     printf("\n+-----------+------------------------------+----------+\n");
     printf("   Cluster ");
     printf("    used                           %4d", 
           $clusterUsage);
     print("%\n");
     printf("               idle                           %4d", 
           $clusterIdle); 
     print("%\n");
     printf("+-----------+------------------------------+----------+\n");
     printf("    Nodes ");
     printf("     up                             %4d\n", $nNodesUp);
     printf("               down                           %4d\n", 
           $nNodesDown);
     printf("               suspecious                     %4d\n", 
           $nNodesSusp);
     printf("               total                          %4d\n", 
           $nNodesAll);
     printf("+-----------+------------------------------+----------+\n");
     printf("    CPUs ");
     printf("      average memory consumption      %4s\n", 
           $nNodesUp == 0 ? "0%" : round($sumMemory/$nNodesUp)."%"); 
     printf("               average CPU consumption         %4s\n",  
           $nNodesUp == 0 ? "0%" : round($sumLoad/$nNodesUp)."%");
     printf("            +------------------------------+----------+\n");
     printf("               free                           %4d\n", 
           $nFreeCPU);
     printf("               used                           %4d\n", 
           $nUsedCPU);
     printf("               down                           %4d\n", 
           $nDownCPU);
     printf("               total                          %4d\n", 
           $nAllCPU);

     # --- dump queue information
#     $dump = `qstat -u $allUsers`;
     $dump = `qstat -u "*"`;
     @line = split(/\n/, $dump);
     
     # --- parse dump
     my @stringState;
     my ($uid, $state);
     for (my $i=2; $i <= $#line; $i++)  {  
        @string = split(/\s+/,$line[$i]);
        $uid    = $string[4];
        $state  = $string[5];
        $jobState{$uid} .= " ".$state;
        $users{$uid}    .= " ";
     }
     my ($nRJobs, $nWJobs, $nEJobs);
     my $nAllRJobs = 0;
     my $nAllWJobs = 0;
     my $nAllEJobs = 0;
     my $nAllUsers = 0;
     foreach $uid (sort keys %users)  {
        $nRJobs   = 0;
        $nWJobs   = 0;
        $nEJobs   = 0;
        $nAllUsers++;
        @stringState = split(/\s+/,$jobState{$uid});
        for (my $i=0; $i <= $#stringState; $i++)  {
           if ($stringState[$i] =~ /[rR]+/)  {
              $nRJobs++;
           }
           if ($stringState[$i] eq "qw")  {
              $nWJobs++;
           }
           if ($stringState[$i] =~ /[eE]+/)  {
              $nEJobs++;
           }
        }
        $nAllRJobs   += $nRJobs;
        $nAllWJobs   += $nWJobs; 
        $nAllEJobs   += $nEJobs;
     } 
     printf("+-----------+------------------------------+----------+\n");
     printf("    Jobs");
     printf("       running                        %4d\n", $nAllRJobs);
     printf("               waiting                        %4d\n", $nAllWJobs);
#printf("               error                          %4d\n", $nAllEJobs);
     printf("+-----------+------------------------------+----------+\n");
     printf("    Users");
     printf("                                     %4d\n", $nAllUsers);
     printf("+-----------+------------------------------+----------+\n");
  }
}
# --- end print nodes information
##############################################################################


##############################################################################
# --- print nodes information 
sub printNodes($)  {

   my $usersList  = shift;
   my ($memoryUsage, $cpuUsage);
   my ($sumMemoryUsage, $sumCpuUsage, $nNodes) = (0,0,0);
   my ($nNodesUp, $nNodesDown)                 = (0,0);  
   my ($nCPUsUp, $nCPUsDown, $nCPUsUsed)       = (0,0,0);
   
   my ($jobsSetup,$hostsSetup) = getHostJobsSetup ($usersList);
   my $detailedJobsSetup       = 
      filterJobs("running",getJobsSetup($usersList));
   my $queueAttributeMap       = getQueueAttributeMap(getQueuesSetup());

   printHeader("nodes");
   foreach my $node (sort keys %$hostsSetup)  {
      if ($node !~ /pc/)  {

      printf("%13s ", centerString($node,10));
      if ($hostsSetup->{$node}{"LOAD"} eq "-")  {
      
         $nCPUsDown += 
            $hostsSetup->{$node}{"NCPU"} eq "-" ? 0 : 
            $hostsSetup->{$node}{"NCPU"};
         $nNodesDown++;
         printf("    DOWN  ");
         if (exists $jobsSetup->{$node})  {
            foreach my $iJob (keys %{$jobsSetup->{$node}})  {
               $nCPUsUsed--;
            }
         }
      
      }  else  {
         $memoryUsage = 100 * toKb($hostsSetup->{$node}{"MEMUSE"}) / 
                              toKb($hostsSetup->{$node}{"MEMTOT"});
         $cpuUsage    = 100 * $hostsSetup->{$node}{"LOAD"} / 
                              $hostsSetup->{$node}{"NCPU"};
         $nCPUsUp        += $hostsSetup->{$node}{"NCPU"}; 
         $sumMemoryUsage += $memoryUsage;
         $sumCpuUsage    += $cpuUsage;
         $nNodesUp++;

         printf("%4d",   $memoryUsage); print ("%|");
         printf("%3d",   $cpuUsage);    print ("%");
      }

      my $jobsInfo = "";
      if (exists $jobsSetup->{$node})  {
         foreach my $iJob (sort keys %{$jobsSetup->{$node}})  {
            if (exists $jobsSetup->{$node}{$iJob})  {
               my $jobID      = $jobsSetup->{$node}{$iJob}{"jobID"};
               my $job        = \%{$detailedJobsSetup->{$jobID}};

               # my $entireNode = $job->{"Hard Resources:"} =~ /entire/ ? 1 : 0;
               my $slots      = 1; # $entireNode == 1 ? $hostsSetup->{$node}{"NCPU"} : 1;
               $nCPUsUsed    += $slots;

               my ($queueName,$mute) = getQueueName($job,$queueAttributeMap);
               $queueName = $jobsSetup->{$node}{$iJob}{"type"} eq "MASTER" ? 
                  $queueName : "~".$queueName;

               $jobsInfo .= sprintf("%22s",  $job->{"user"}."(".$queueName.")");
               $jobsInfo .= sprintf("%10s",  $jobID);
               $jobsInfo .= sprintf("\n                        ");
            }
         }
      }  else  {
         print("\n");
      }
      print $jobsInfo;
      print("\n"); 
      }
   }

   my $nCPUsAll  = $nCPUsUp + $nCPUsDown;
   my $nCPUsFree = $nCPUsUp - $nCPUsUsed; 
   printFooter("nodes");
   printf("   average    ");
   printf("%4d", $nNodesUp == 0 ? 0 : $sumMemoryUsage/$nNodesUp); print ("%|");
   printf("%3d", $nNodesUp == 0 ? 0 : $sumCpuUsage/$nNodesUp);    print ("%");
#   printf("     $nCPUsFree cores free\n");
   printf("\n     cores   $nCPUsFree free | $nCPUsUsed used | ");
   print("$nCPUsDown down | $nCPUsAll total");
   printFooter("nodes");  
}
# --- end print nodes information
##############################################################################


##############################################################################
# --- print queues information 
sub printQueues()  {
  
   my $queuesSetup   = getQueuesSetup();
   my $queuesSummary = getQueuesSummary();
   my $complexSetup  = getComplexSetup();
   my %queuesInfo; 
   
   # --- process queues setup
   foreach my $queue (sort {$a lt $b} keys %$queuesSetup)  {
      my $qSetup   = \%{$queuesSetup->{$queue}};
      my $qSummary = \%{$queuesSummary->{$queue}};
      my $queueName;
      # -- assume here that system queue name consists of forced attribute
      #    name + some differences, e.g.: 
      #    attribute = cmpar4w
      #    queueName = cmpar4w1 and cmpar4w2 for part of the queues that are
      #    located on different switches
      my @queueComplex = split(/,/,
                         $qSetup->{"complex_values"}); 
      for (my $i=0; $i < @queueComplex; $i++)  {
         $queueComplex[$i] =~ s/=TRUE//;
         if ($queue =~ /$queueComplex[$i](\d+)?/)  { 
            $queueName = $queueComplex[$i]; 
         }
      }

      my $qInfo = \%{$queuesInfo{$queueName}};
      
      if (!exists $qInfo->{"usedCPU"})   { $qInfo->{"usedCPU"}  = 0; }
      if (!exists $qInfo->{"availCPU"})  { $qInfo->{"availCPU"} = 0; }
      $qInfo->{"usedCPU"}  += $qSummary->{"USED"};
      $qInfo->{"maxCPU"}   += $qSummary->{"TOTAL"};   
      $qInfo->{"priority"}  = $complexSetup->{$queueName}{"urgency"}; 
      $qInfo->{"time"}      = $qSetup->{"h_rt"} eq "INFINITY" ?
                              $qSetup->{"h_rt"} : 
                              seconds2dhm(toSec($qSetup->{"h_rt"}));
      if ($qSetup->{"pe_list"} eq "NONE")  {
         $qInfo->{"type"} = "SEQ";
      }  else  {
         if ($qSetup->{"qtype"} eq "NONE")  {
            $qInfo->{"type"} = "PAR";
         }  else  {
            $qInfo->{"type"} = "SEQ|PAR";
         }
      }
   }

   printHeader("queues");
   foreach my $queue (sort keys %queuesInfo)  {
      my $qInfo = \%{$queuesInfo{$queue}};
      printf("%12s   ", $queue);
      printf("%4d    ", $qInfo->{"usedCPU"});
      printf("%7d    ", $qInfo->{"maxCPU"});
      printf("%5d "   , $qInfo->{"priority"});
      printf("%11s  ",   $qInfo->{"time"});
      printf("%9s\n",   centerString($qInfo->{"type"},9));
   }
   printFooter("queues"); 
}
# --- end print queues information
##############################################################################

##############################################################################
# --- print departments information 
sub printProjects()  { 

  # --- my info-containers 
  my %nCPUs; my %projectUsers; my %projectShares; my %userDefaults;
  my %userShares;

  my $hostsSetup        = getHostsSetup  ();
  my $jobsSetup         = getJobsSetup   ("-u \"*\"");
  my $queuesSetup       = getQueuesSetup ();
  my $queueAttributeMap = getQueueAttributeMap($queuesSetup);

  # --- get amount of available cpus 
  my $nAllCPUs = 0;
  my $sumLoad  = 0;
  foreach my $host (keys %$hostsSetup)  {
     if ($hostsSetup->{$host}{"LOAD"} ne "-")  {
        $nAllCPUs += $hostsSetup->{$host}{"NCPU"};
        $sumLoad  += $hostsSetup->{$host}{"LOAD"};
     }
  }
#$sumLoad /= $nAllCPUs;

  # --- sort jobs according to job's state and user
  my %userJobs; 
  foreach my $jobID (keys %$jobsSetup)  {
     my $job        = \%{$jobsSetup->{$jobID}};
     my $user       = $job->{"user"};
     my $entireNode = $job->{"Hard Resources:"} =~ /entire/ ? 1 : 0; 
     my $slots      = $job->{"slots"};
	  my $host       = $job->{"host"};
     my $state      = $job->{"state"};
     
     if (!exists $userJobs{$user})  {
        ($userJobs{$user}{"nSlots"},$userJobs{$user}{"nPercents"}) = (0,0);
     }
     
     if ($state =~ /[rR]/)  {
        $slots = $entireNode == 1 ? $hostsSetup->{$host}{"NCPU"} : $slots;
        $userJobs{$user}{"nSlots"}    += $slots;
        $userJobs{$user}{"nPercents"} += $slots * ($hostsSetup->{$host}{"LOAD"}/$hostsSetup->{$host}{"NCPU"});
     }
  }

  foreach my $uid (keys %userJobs)  {
     my $nCPUs = round(100*$userJobs{$uid}{"nSlots"}/$nAllCPUs);
     my $load  = round(100*$userJobs{$uid}{"nPercents"}/$sumLoad);
     print("$uid $nCPUs % $load %\n");
  }
  

}
# --- end print deparments information
##############################################################################


##############################################################################
# --- print users information 
sub printUsers($)  {

  my $usersList  = shift; 

  my $hostsSetup        = getHostsSetup  ();
  my $jobsSetup         = getJobsSetup   ($usersList);
  my $queuesSetup       = getQueuesSetup ();
  my $queueAttributeMap = getQueueAttributeMap($queuesSetup);

  # --- get amount of available cpus 
  my $nAllCPUs = 0; 
  foreach my $host (keys %$hostsSetup)  {
     if ($host !~ /pc/)  {
     if ($hostsSetup->{$host}{"LOAD"} ne "-")  {
        $nAllCPUs += $hostsSetup->{$host}{"NCPU"};
     }
     }
  }
 
  # --- sort jobs according to job's state and user
  my %userJobs; 
  foreach my $jobID (keys %$jobsSetup)  {
     my $job        = \%{$jobsSetup->{$jobID}};
     my $user       = $job->{"user"};
     my $entireNode = $job->{"Hard Resources:"} =~ /entire/ ? 1 : 0; 
     my $slots      = $job->{"slots"};
     my $host       = $job->{"host"};
     
     if (!exists $userJobs{$user})  {
        ($userJobs{$user}{"running"},$userJobs{$user}{"waiting"})      = (0,0);
        ($userJobs{$user}{"hold"},   $userJobs{$user}{"ncpu_running"}) = (0,0); 
        ($userJobs{$user}{"suspend"},$userJobs{$user}{"delete"})       = (0,0);
        ($userJobs{$user}{"error"},  $userJobs{$user}{"ncpu_waiting"}) = (0,0);
        ($userJobs{$user}{"time_waiting"}) = (0);
     }

     my $state = $job->{"state"};
     if ($state =~ /[rR]/)  {
        $slots = $entireNode == 1 ? $hostsSetup->{$host}{"NCPU"} : $slots;
        $userJobs{$user}{"running"}++; 
        $userJobs{$user}{"ncpu_running"} += $slots; 
     }
     if ($state =~ /qw/  )  { 
        $userJobs{$user}{"waiting"}++;
        $userJobs{$user}{"ncpu_waiting"} += $slots;
     }
     if ($state =~ /[hH]/)  { $userJobs{$user}{"hold"}++    }
     if ($state =~ /[sS]/)  { $userJobs{$user}{"suspend"}++ }
     if ($state =~ /[d]/)   { $userJobs{$user}{"delete"}++  }

     my ($userQueueName,$systemQueueName) = 
        getQueueName($job,$queueAttributeMap);

     $state = exists($queuesSetup->{$systemQueueName}) ? 
        checkErrors ($job,$queuesSetup->{$systemQueueName}) :
           checkErrors ($job,$systemQueueName);

     if ($state !~ "OK\*")    { $userJobs{$user}{"error"}++ }
  }


  # --- sort users by maximum running cpus
  my @sortedUsers = sort  {$userJobs{$b}{"ncpu_running"}<=>
                           $userJobs{$a}{"ncpu_running"}} 
                    keys %userJobs;
   
  my %sum;
  ($sum{"running"},$sum{"waiting"},$sum{"hold"},$sum{"ncpu_running"})          = (0,0,0,0); 
  ($sum{"suspend"},$sum{"delete"},$sum{"error"},$sum{"ncpu_waiting"})          = (0,0,0,0);
  
  my $body = "";
  # --- loop over users     
  for (my $i=0; $i < @sortedUsers; $i++)  {
     my $user = $sortedUsers[$i];
     my $job  = \%{$userJobs{$user}};

     foreach my $type (keys %sum)  {
        $sum{$type} += $job->{$type};
     }
     
     $body .= sprintf("\n%12s       ", $user);
     $body .= sprintf("%4d|", $job->{"running"});
     $body .= sprintf("%4d|", $job->{"ncpu_running"});
     $body .= sprintf("%4d",  round(100*$job->{"ncpu_running"}/$nAllCPUs));
     $body .= "%      ";
     $body .= sprintf("  %4d|",        $job->{"waiting"});
     $body .= sprintf("%4d       ",    $job->{"ncpu_waiting"});
     $body .= sprintf("%3d   ",        $job->{"hold"});
     $body .= sprintf("%4d  ",         $job->{"suspend"});
     $body .= sprintf("%4d  ",         $job->{"delete"});
     $body .= sprintf("%4d",           $job->{"error"});
  }


  if (length($body) > 0)  {
     printHeader("user_statistics");
     print($body);
     printFooter("user_statistics");
  }  else  {
     print("\n  No running/queued jobs");
  } 
  my @nLines = split(/\n/,$body);
  
  if (@nLines > 2)  {
     printf("     TOTAL         ");
     printf("%4d|",          $sum{"running"});
     printf("%4d|",          $sum{"ncpu_running"});
     printf("%4d",           round(100*$sum{"ncpu_running"}/$nAllCPUs));
     print ("%      ");
     printf("  %4d|",        $sum{"waiting"});
     printf("%4d       ",    $sum{"ncpu_waiting"});
     printf("%3d   ",        $sum{"hold"});
     printf("%4d  ",         $sum{"suspend"});
     printf("%4d  ",         $sum{"delete"});
     printf("%4d",           $sum{"error"});

     # --- get amount of available cpus 
     my $nAllCPUs = 0; 
     foreach my $host (keys %$hostsSetup)  {
       if ($host =~ /cmdft/)  {
       if ($hostsSetup->{$host}{"LOAD"} ne "-")  {
           $nAllCPUs += $hostsSetup->{$host}{"NCPU"};
       }
       }
     }
 
     # --- sort jobs according to job's state and user
     my %userJobs; 
     foreach my $jobID (keys %$jobsSetup)  {
     my $job        = \%{$jobsSetup->{$jobID}};
     my $user       = $job->{"user"};
     my $entireNode = $job->{"Hard Resources:"} =~ /entire/ ? 1 : 0; 
     my $slots      = $job->{"slots"};
     my $host       = $job->{"host"}; if ($host =~ /cmdft/)  {
     
     if (!exists $userJobs{$user})  {
        ($userJobs{$user}{"running"},$userJobs{$user}{"ncpu_running"}) = (0,0);
     }

     my $state = $job->{"state"};
     if ($state =~ /[rR]/)  {
        $slots = $entireNode == 1 ? $hostsSetup->{$host}{"NCPU"} : $slots;
        $userJobs{$user}{"running"}++; 
        $userJobs{$user}{"ncpu_running"} += $slots; 
     }
     }
  }


  # --- sort users by maximum running cpus
  my @sortedUsers = sort  {$userJobs{$b}{"ncpu_running"}<=>
                           $userJobs{$a}{"ncpu_running"}} 
                    keys %userJobs;
   
  my %sum;
  ($sum{"running"},$sum{"ncpu_running"}) = (0,0); 
  
  my $body = "";
  # --- loop over users     
  for (my $i=0; $i < @sortedUsers; $i++)  {
     my $user = $sortedUsers[$i];
     my $job  = \%{$userJobs{$user}};

     $sum{"running"} += $job->{"running"};
     $sum{"ncpu_running"} += $job->{"ncpu_running"};
     
     $body .= sprintf("\n%12s       ", $user);
     $body .= sprintf("%4d|", $job->{"running"});
     $body .= sprintf("%4d|", $job->{"ncpu_running"});
     $body .= sprintf("%4d",  round(100*$job->{"ncpu_running"}/$nAllCPUs));
  }
 
     
  printf("\n     cmdft         ");
  printf("%4d|",          $sum{"running"});
  printf("%4d|",          $sum{"ncpu_running"});
  printf("%4d",           round(100*$sum{"ncpu_running"}/$nAllCPUs));
  print ("%     \n ");

  # --- get amount of available cpus 
  $nAllCPUs = 0; 
  foreach my $host (keys %$hostsSetup)  {
    if ($host =~ /cmmd/)  {
    if ($hostsSetup->{$host}{"LOAD"} ne "-")  {
        $nAllCPUs += $hostsSetup->{$host}{"NCPU"};
    }
    }
  }
 
  # --- sort jobs according to job's state and user
  %userJobs = ();
  foreach my $jobID (keys %$jobsSetup)  {
     my $job        = \%{$jobsSetup->{$jobID}};
     my $user       = $job->{"user"};
     my $entireNode = $job->{"Hard Resources:"} =~ /entire/ ? 1 : 0; 
     my $slots      = $job->{"slots"};
     my $host       = $job->{"host"}; if ($host =~ /cmmd/)  {
     
     if (!exists $userJobs{$user})  {
        ($userJobs{$user}{"running"},$userJobs{$user}{"ncpu_running"}) = (0,0);
     }

     my $state = $job->{"state"};
     if ($state =~ /[rR]/)  {
        $slots = $entireNode == 1 ? $hostsSetup->{$host}{"NCPU"} : $slots;
        $userJobs{$user}{"running"}++; 
        $userJobs{$user}{"ncpu_running"} += $slots; 
     }
     }
  }


  # --- sort users by maximum running cpus
  @sortedUsers = sort  {$userJobs{$b}{"ncpu_running"}<=>
                        $userJobs{$a}{"ncpu_running"}} 
                 keys %userJobs;
  
  %sum = (); 
  ($sum{"running"},$sum{"ncpu_running"}) = (0,0); 
  
  $body = "";
  # --- loop over users     
  for (my $i=0; $i < @sortedUsers; $i++)  {
     my $user = $sortedUsers[$i];
     my $job  = \%{$userJobs{$user}};

     $sum{"running"} += $job->{"running"};
     $sum{"ncpu_running"} += $job->{"ncpu_running"};
     
     $body .= sprintf("\n%12s       ", $user);
     $body .= sprintf("%4d|", $job->{"running"});
     $body .= sprintf("%4d|", $job->{"ncpu_running"});
     $body .= sprintf("%4d",  round(100*$job->{"ncpu_running"}/$nAllCPUs));
  }
 
     
  printf("     cmmd         ");
  printf("%4d|",          $sum{"running"});
  printf("%4d|",          $sum{"ncpu_running"});
  printf("%4d",           round(100*$sum{"ncpu_running"}/$nAllCPUs));
  print ("%      ");

  printFooter("user_statistics");
  }
 
}
# --- end print users information
##############################################################################


##############################################################################
# --- print queued jobs information 
sub printWaiting(%)  { 
  
  my ($arg)     = @_;
  my $usersList = $arg->{"printUsers"};
  my $jobsType  = $arg->{"jobsType"};

  my $queuesSetup       = getQueuesSetup ();
  my $queueAttributeMap = getQueueAttributeMap($queuesSetup);
  my $queuedJobs        = 
     split2SeqParJobs(filterJobs("waiting",getJobsSetup($usersList)));
  my $localTime         = time();

  my ($job, $jobID);
  my ($userQueueName, $systemQueueName);
  my ($state, $waitTime, $priority, $clusterPart);
  
  # --- sort jobs according to priorities
  my $body        = "";
  my $hint        = "";
  my (%jobs, @sortedJobID, $maxPriority); 

  %jobs = (); 
  foreach my $type (@{$jobsType})  {
     if (exists $queuedJobs->{$type})  {
       	@jobs{keys %{$queuedJobs->{$type}}} = values %{$queuedJobs->{$type}};
     }
  }

  @sortedJobID = sort  {$jobs{$b}{"priority"}<=>
                        $jobs{$a}{"priority"}} 
                 keys %jobs;
  # --- save the highest priority
  $maxPriority = $jobs{$sortedJobID[0]}{"priority"};

             
     # --- loop over jobs 
     for (my $i=0; $i < @sortedJobID; $i++)  {
        
        $jobID        = $sortedJobID[$i];
        $job          = \%{$jobs{$jobID}};
        $clusterPart  = "";
        if (exists $job->{"Hard Resources:"})  {
           if ($job->{"Hard Resources:"} =~ /cmdft/)  {
              $clusterPart .= "cmdft";
           }  
           if ($job->{"Hard Resources:"} =~ /cmmd/)  {
              if ($clusterPart eq "")  {
                 $clusterPart  = "cmmd";
              }  else  {
                 $clusterPart .= "|cmmd";
              }
           }  
        }
        if ($clusterPart eq "")  {
           $clusterPart = "unspec";
        }
        

        $priority = $maxPriority == 0 ? "inf" 
                                      : 100*$job->{"priority"}/$maxPriority;

        ($userQueueName,$systemQueueName) = getQueueName($job,$queueAttributeMap);

        $state    = exists($queuesSetup->{$systemQueueName}) ? 
           checkErrors ($job,$queuesSetup->{$systemQueueName}) :
              checkErrors ($job,$systemQueueName);
        $hint    .= $state;

        $waitTime = seconds2dhm ($localTime - 
              toEpochTime($job->{"date"},$job->{"time"}));

        my $pe = "unspec";
        if (exists $job->{"Requested PE:"})  {
           $pe =  $job->{"Requested PE:"};
           $userQueueName = "parallel"; 
        }  else  {
           $userQueueName = "serial";  
        }

        $body .= sprintf("\n%4d     ", $i+1);
        $body .= sprintf("%6.2f   "  , $priority);
        $body .= sprintf("%22s ", cutString($job->{"Full jobname:"},21,5));
        $body .= sprintf("%23s ", $job->{"user"}."(".$userQueueName.")");
        $body .= sprintf("%10s ", $waitTime);
        $body .= sprintf("%7d"  , $job->{"slots"});
        $body .= sprintf("%11d  ", $jobID);
        $body .= sprintf("%10s" , centerString($state,10));
        $body .= sprintf("%10s" , centerString($clusterPart,9));

        $body .= sprintf("%10s" , centerString($pe,10));
        
     }
     if (length($body) > 0)  {
        printHeader("waiting"); 
        print($body); 
        printFooter("waiting");
        printHint($hint);
     }  else  {
        
        print("\n  No queued jobs");
     }
}
# --- end print queued jobs information
##############################################################################

##############################################################################
# --- print queued jobs information 
sub printAverageWTime(%)  { 
  
  my ($arg)     = @_;
  my $usersList = $arg->{"printUsers"};
  my $jobsType  = $arg->{"jobsType"};

  my $queuedJobs  = 
     split2SeqParJobs(filterJobs("waiting",getJobsSetup($usersList)));
  my $localTime   = time();

  my (%waitTime,%nJobs,%nCPUs,$type,$time);
  my (%totalWTime,%nAllJobs,%nAllCPUs);
  my ($job, $jobID, @sortedJobID);
  
  foreach $type (@{$jobsType})  {
     # --- sort jobs according to priorities
     my (%jobs, @sortedJobID, $user); 
     if (exists $queuedJobs->{$type})  {
        %jobs        = %{$queuedJobs->{$type}};
        @sortedJobID = sort  {$jobs{$b}{"priority"}<=>
                              $jobs{$a}{"priority"}} 
                       keys %jobs;
     }
     # --- loop over jobs
     $nAllJobs{$type} = $nAllCPUs{$type} = $totalWTime{$type} = 0;
     for (my $i=0; $i < @sortedJobID; $i++)  { 

        $jobID = $sortedJobID[$i];
        $job   = \%{$jobs{$jobID}};
        $user = $job->{"user"};

        if (!exists $waitTime{$user}{$type})  {
           ($waitTime{$user}{$type},$nJobs{$user}{$type},$nCPUs{$user}{$type}) = (0,0,0);
        }
        $time = $localTime - toEpochTime($job->{"date"},$job->{"time"});
        $waitTime{$user}{$type} += $time;
        $totalWTime{$type}      += $time;
        $nCPUs{$user}{$type}    += $job->{"slots"};
        $nAllCPUs{$type}        += $job->{"slots"};
        $nJobs{$user}{$type}++;
        $nAllJobs{$type}++;
     }
  }

  my $body = "";
  foreach my $user (sort keys %waitTime)  {
     $body .= sprintf("\n%12s      ", $user);
     $type = "serial"; 
     if (exists $waitTime{$user}{$type})  {
        $body .= sprintf("%9s  |", seconds2dhm($waitTime{$user}{$type}/$nJobs{$user}{$type}));
     }  else  {
        $body .= sprintf("%9s  |","-");
     }
     $type = "parallel";
     if (exists $waitTime{$user}{$type})  {
        $body .= sprintf("   %9s / ", seconds2dhm($waitTime{$user}{$type}/$nJobs{$user}{$type}));
        $body .= sprintf(" %9s",     seconds2dhm($waitTime{$user}{$type}/$nCPUs{$user}{$type}));
     }  else  {
        $body .= sprintf("     %9s  ","-");
     }
  }
  $body .= "\n+-------------+--------------+-----------------------------+\n";
  $body .= "       TOTAL      ";
  $type  = "serial";
  if ($nAllJobs{$type} > 0)  {
     $body .= sprintf("%9s  |", seconds2dhm($totalWTime{$type}/$nAllJobs{$type}));
  }  else  {
     $body .= sprintf("%9s  |","-");
  }
  $type = "parallel";
  if ($nAllJobs{$type} > 0)  {
     $body .= sprintf("   %9s / ", seconds2dhm($totalWTime{$type}/$nAllJobs{$type}));
     $body .= sprintf(" %9s",     seconds2dhm($totalWTime{$type}/$nAllCPUs{$type}));
  }  else  {
     $body .= sprintf("     %9s  ","-");
  }
  $body .= "\n+-------------+--------------+-----------------------------+\n";

  if (length($body) > 0)  {
     printHeader("average_waiting_time");
     print($body);
  }  else  {
     print("\n  No waiting jobs\n");
  }  
}
# --- end print queued jobs information
##############################################################################

##############################################################################
#
sub round($) {
    my($number) = shift;
    return int($number + .5 * ($number <=> 0));
}
#
##############################################################################

##############################################################################
#
sub nextItem($$)  {
   my ($string, $key) = ($_[0], $_[1]);
   my $length   = length($key) + 1;
   my $indexKey = index ($string, $key);
   my $indexEnd = index ($string," ",$indexKey + $length);
   return substr($string, $indexKey + $length, $indexEnd-$indexKey-$length); 
}
#
##############################################################################

##############################################################################
#
sub cutString($$$)  {
   my $string      = shift;
   my $lengthWhole = shift;
   my $lengthEnd   = shift;
   
   my $length = length($string);
   my $res;
   if ($length <= $lengthWhole)  {
      return $string;
   }  else  {
      my $begin = substr($string, 0, $lengthWhole - $lengthEnd - 2);
      my $end   = substr($string, $length - $lengthEnd, $lengthEnd);
      return $begin."..".$end;
   }
}
#
##############################################################################

##############################################################################
#
sub toEpochTime($$)  {
   my $date = shift; 
   my $time = shift;

   my ($hour,$min,$sec)   = split(/:/, $time);
   my ($month,$day,$year) = split(/\//,$date); $month--; $year-=1900;
  
#   print("h=$hour,m=$min,s=$sec,m=$month,d=$day,y=$year\n"); 
   return timelocal($sec,$min,$hour,$day,$month,$year);
}
#
##############################################################################

##############################################################################
#
sub seconds2dhm($)  {
   my $time = $_[0]; # in sec

   my $days  = int($time/86400);                            # 86400 = 24*60*60
   my $hours = int(($time - $days*86400)/3600);             # 3600  = 60*60
   my $min   = int(($time - $days*86400 - $hours*3600)/60); # 60    = 60
  
   $hours    = ($hours < 10) ? "0".$hours : $hours;
   $min      = ($min < 10) ? "0".$min : $min;

   return "$days:$hours:$min";
}
#
##############################################################################

##############################################################################
#
sub isOddNumber($)  {
   return $_[0] % 2;
}
#
##############################################################################

##############################################################################
#
sub printHint($)  {
   my $state = shift;
   if ($state =~ "0")  {
      printf(" `(0) - the serial jobs requesting entire node are considered");
      printf(" as parallel\n");
   }
   if ($state =~ "1")  { 
      printf(" `(1) - either the job is submitted with \"qsub -q queue\"");
      printf(" instead of required \"qsub -l queue\" and/or\n");
      printf("      - there is a typo in the queue name\n");
   }
   if ($state =~ "2")  {  
      printf(" `(2) - parallel job is submitted to serial queue\n");  
   }
   if ($state =~ "3")  {  
      printf(" `(3) - wrong parallel environment is specified\n");
      printf("      - parallel jobs should be submitted only with \"qsub");
      printf(" -pe mpi* ...\" or \"qsub -pe threaded ...\"\n");  
   }
   if ($state =~ "4")  {  
      printf(" `(4) - parallel job should not request odd number of CPUs\n");  
   }
   if ($state =~ "5")  {  
      printf(" `(5) - parallel jobs should be submitted only with \"qsub");
      printf(" -pe mpi* ...\" or \"qsub -pe threaded ...\"\n");
   }
   if ($state =~ "6")  {  
      printf(" `(6) - serial job is submitted to parallel queue\n");  
   }
   if ($state =~ "7")  {  
      printf(" `(7) - queuing system keeps job in \"Error\" state\n");  
   }
   if ($state =~ "8")  { 
      printf(" `(8) - job is in \"Hold\" state\n");  
   }
   if ($state =~ "9")  {  
      printf(" `(9) - job is in \"Suspend\" state\n");  
   }
}
#
##############################################################################

##############################################################################
#
sub centerString($$)  {
   my $string       = $_[0];
   my $spaceLength  = $_[1] - length($string);
   for (my $i=0; $i < $spaceLength/2; $i++)  {
      $string = " ".$string." ";
   }
   if (isOddNumber($spaceLength) && $spaceLength > 0)  { 
      $string .= " "; 
   }
   return $string;
}
#
##############################################################################

##############################################################################
#
sub printHeader($)  {
   my $type = shift;
   for ($type)  {
      if (/average_waiting_time/)  {
         printf("\n+-------------+-----------------------------------------");
         printf("---+");
         printf("\n                       AVERAGE WAITING TIME (d.h.m) ");
         printf("\n     USER           Serial      Parallel (per job/per core)");
         printf("\n+-------------+--------------+--------------------------");
         printf("---+");
      }
      if (/waiting_serial/)  {
         printf("\n                                             Serial part\n");
         printf("\n+-----+----------+-----------------------+-------------");
         printf("---------+-------------+---------+----------+--------+");
         print ("\n ORDER  PRIOR(%)            JOB                ");
         printf("USER(QUEUE)       W.TIME(d:h:m)   JOB_ID    STATE");
         printf("      NODES");
         printf("\n+-----+----------+-----------------------+-------------");
         printf("---------+-------------+---------+----------+--------+");     
      }
      if (/waiting_parallel/)  {
         printf("\n");
         printf("\n                                                 Parallel");
         printf(" part\n");
         printf("\n+-----+----------+-----------------------+-------------");
         printf("---------+-------------+------+---------+----------+");
         printf("--------+");
         print ("\n ORDER  PRIOR(%)           JOB                 ");
         printf("USER(QUEUE)       W.TIME(d:h:m)  nCores  JOB_ID    STATE");
         printf("      NODES");
         printf("\n+-----+----------+-----------------------+-------------");
         printf("---------+-------------+------+---------+----------+");
         printf("--------+");
      }
      if (/^waiting/)  {
         printf("\n");
         printf("\n+-----+----------+-----------------------+-------------");
         printf("---------+-------------+------+---------+----------+");
         printf("--------+----------+");
         print ("\n ORDER  PRIOR(%)           JOB                 ");
         printf("USER(QUEUE)       W.TIME(d:h:m) nCores   JOB_ID    STATE");
         printf("      NODES      PE");
         printf("\n+-----+----------+-----------------------+-------------");
         printf("---------+-------------+------+---------+----------+");
         printf("--------+----------+");
      }
      if (/user_statistics/)  {
         printf("\n+-------------+-----------------------+----------------");
         printf("-+------+------+-----+-----+");
         printf("\n     USER      RUN(jobs|cores|CLUSTER)  WAIT(jobs|cores)");
         printf("  HOLD   SUSP   DEL   ERR");
         printf("\n+-------------+-----------------------+----------------");
         printf("-+------+------+-----+-----+");
      }
      if (/running_detailed/)  {
          printf("\n+--------------+-----------------------+--------------");
          printf("--------+-------------+---------+");
          printf("\n      NODE                JOB                 ");
          printf("USER(QUEUE)      R.TIME(d:h:m)   JOB_ID        ");
          printf("\n+--------------+-----------------------+--------------");
          printf("--------+-------------+---------+\n");
      }
      if (/nodes/)  {
         printf("\n+-----------+-------------+-------------------+-----------");
         printf("\n    NODE        MEM|CORES      USER(QUEUE)    |  JOB_ID ");
         printf("\n+-----------+-------------+-------------------+-----------\n");
      }
      if (/queues/)  {
         printf("\n+------------+---------+--------+-------+------");
         printf("-------+-------+");
         printf("\n    QUEUE      usedCores maxCores PRIOR   ");
         printf("TIME(d:h:m)    TYPE  ");
         printf("\n+------------+---------+--------+-------+------");
         printf("-------+-------+\n");
      }
   }
}
#
##############################################################################

##############################################################################
#
sub printFooter($)  {
   my $type = shift;
   for ($type)  {
      if (/waiting_serial/)  {
         printf("\n+-----+----------+-----------------------+--------------");
         printf("--------+-------------+---------+----------+--------+\n");     
      }
      if (/waiting_parallel/)  {
         printf("\n+-----+----------+-----------------------+--------------");
         printf("--------+-------------+------+---------+----------+--------+\n");
      }
      if (/waiting/)  {
         printf("\n+-----+----------+-----------------------+--------------");
         printf("--------+-------------+------+---------+----------+--------+----------+\n");
      }
      if (/user_statistics/)  {
         printf("\n+-------------+-----------------------+-----------------");
         printf("+------+------+-----+-----+\n");
      }
      if (/running_detailed/)  {
         printf("+--------------+-----------------------+------------------");
         printf("----+-------------+---------+\n");
      }
      if (/nodes/)  {
           printf("\n+-----------+-------------+-------------------+-----------\n");
      }
      if (/queues/)  {
         printf("+------------+---------+--------+-------+--------");
         printf("-----+-------+\n");
      }
   }
}
#
##############################################################################

##############################################################################
#  --- Check if the job fulfils the syntax and requests valid resources
sub checkErrors($$)  {
   my $job   = shift;
   my $queue = shift;
   my @state;
   my $stateOut;

   # --- if the job is running it cannot be setup in a wrong way
   if ($job->{"state"} =~ /[rR]/)  {
      $stateOut = "OK";
   }  else  {

      # --- check if the queue is defined
      if ($queue eq "---")  {
         push (@state, 1);
      }  else  {
         # --- check if the job is the serial
         #     that requests entire node (CM-specific)
         #if (exists $job->{"Hard Resources:"})  {
         #   if ($job->{"Hard Resources:"} =~ /entire/)  {
#               push (@state, 0);
         #   }
         #}
         
         # --- check parallel environment
         if (exists $job->{"Requested PE:"})  {         
            # -- prevent parallel job to be 
            #    submitted to the serial queue
            #if ($queue->{"pe_list"} eq "NONE")  {
            #   push (@state, 2);
            #}
            
            # -- check if the requested PE exists
            $job->{"Requested PE:"} =~ s/\s\d+$//g;
            # -- TEMPORARY SOLUTION, HARDCODED VERSION 
            # $queue->{"pe_list"} .= "threaded mpi";
            # -- check explicit request
            #if ($queue->{"pe_list"} !~ /$job->{"Requested PE:"}/)  { 
            #   $job->{"Requested PE:"} =~ s/\*//g;
               # - check implicit request with wildcarts
            #   if ($queue->{"pe_list"} !~ /$job->{"Requested PE:"}/)  {
            #      push (@state, 3);
            #   }
            #}
         
            # -- check if the number of CPUs odd/even
            #if (isOddNumber($job->{"slots"}))  {
            #   push (@state, 4);
            #}
         
            # -- check if requested PE fulfils the required
            #    syntax
            if ($job->{"Requested PE:"} !~ /mpi(dft?)/ &&
                $job->{"Requested PE:"} !~ /mpi/ &&  
                $job->{"Requested PE:"} !~ /serial/  )  {
               push (@state, 5);
            }
         }  else  {
            # -- prevent serial job to be 
            #   submitted to the parallel queue
            #if ($queue->{"pe_list"} ne "NONE" && 
            #    $queue->{"qtype"}   eq "NONE")  {
            #   push (@state, 6);
            #}
         }
      }	
   
      # --- check error state
      if ($job->{"state"} =~ /[eE]/)  {
         push (@state, 7);
      }
      
      # --- check hold state
      if ($job->{"state"} =~ /[h]/)  {
         push (@state, 8);
      }
   
      # --- check suspend state
      if ($job->{"state"} =~ /[sS]/)  {
         push (@state, 9);
      }
  

      # --- construct the print-out string 
      if (@state == 0)  {
         $stateOut = "OK";
      }  else  {
         $stateOut = join(",",@state);
         # -- state 7-8 are simple warnings, in contrast
         #    to 1-6 that are real errors
         $stateOut = $stateOut =~ /[1-7]/ ? "ERR(".$stateOut.")" 
                                          : "OK(" .$stateOut.")";
      }
      
   }
   return $stateOut;
}
#
##############################################################################

##############################################################################
# --- get queue names
sub getQueueNames()  {
   return split(/\n/,`qconf -sql`);
}
#
##############################################################################

##############################################################################
# --- create queues-config hash
sub getQueuesSetup()  {
   my (%queuesSetup, $string, $queue, $parameter);
   my @queueNames = getQueueNames();
   my @configDump = split(/\n/,`qconf -sq @queueNames`);

   $parameter = "undefined";
   foreach $string (@configDump) {
      for ($string)  {
        #if (/^qname\s+(\S+)/)  {
         if (/^qname\s+(\w+)/)  { 
            $queue = $1;
         }
         elsif (/^(\w+)\s+(.+)/)  {
            $parameter = $1;
            $queuesSetup{$queue}{$parameter}  = $2;
         } 
         elsif (/^\s+(.+)/)  {
            $queuesSetup{$queue}{$parameter} .= $1;
         }
      }
   }
   
   return \%queuesSetup;
}
#
##############################################################################

##############################################################################
# --- create queues-config hash
sub getQueuesSummary()  {
   my (%queuesSummary, @string, $queue);
   my @configDump = split(/\n/,`qstat -g c`);

   for (my $i=2; $i < @configDump; $i++)  {
      @string = split(/\s+/,$configDump[$i]);
      $queue  = $string[0];
      $queuesSummary{$queue}{"CQLOAD"} = $string[1];
      $queuesSummary{$queue}{"USED"}   = $string[2];
      $queuesSummary{$queue}{"AVAIL"}  = $string[3];
      $queuesSummary{$queue}{"TOTAL"}  = $string[4];
      $queuesSummary{$queue}{"aoACDS"} = $string[5];
      $queuesSummary{$queue}{"cdsuE"}  = $string[6];
   }
   
   return \%queuesSummary;
}
#
##############################################################################

##############################################################################
# --- create host-config and job-config hashes
sub getHostJobsSetup($)  {

   my $usersList  = shift;

   my (%hostsSetup, %jobsSetup, @string, $host, $iJob);
   my @configDump = split(/\n/,`qhost -j $usersList`);

   # --- skip header and global host
   for (my $i=3; $i < @configDump; $i++)  {
      # -- skip job header
      if ($configDump[$i] !~ /^   job-ID/ || 
          $configDump[$i] !~ /^   ------/)  {
         
         @string = split(/\s+/,$configDump[$i]);
         # - have master job 
         if ($configDump[$i] =~ /^\s*\d+/)  {
            $jobsSetup{$host}{$iJob}{"jobID"}    = $string[1];
            $jobsSetup{$host}{$iJob}{"priority"} = $string[2];
            $jobsSetup{$host}{$iJob}{"name"}     = $string[3];
            $jobsSetup{$host}{$iJob}{"user"}     = $string[4];
            $jobsSetup{$host}{$iJob}{"state"}    = $string[5];
            $jobsSetup{$host}{$iJob}{"date"}     = $string[6];
            $jobsSetup{$host}{$iJob}{"time"}     = $string[7];
            $jobsSetup{$host}{$iJob}{"type"}     = $string[9];
            $iJob++;
         }
         # - have slave job
         if ($configDump[$i] =~ /^             / && $iJob > 0)  {
            %{$jobsSetup{$host}{$iJob}} = %{$jobsSetup{$host}{$iJob-1}};
            $jobsSetup{$host}{$iJob}{"type"} = "SLAVE";
            $iJob++;
         } 
         # - have host description  
         if ($configDump[$i] =~ /^[a-zA-Z]+/)  { 
            $iJob = 0;
            $host = $string[0];
            $hostsSetup{$host}{"ARCH"}   = $string[1];
            $hostsSetup{$host}{"NCPU"}   = $string[2];
            $hostsSetup{$host}{"LOAD"}   = $string[3];
            $hostsSetup{$host}{"MEMTOT"} = $string[4];
            $hostsSetup{$host}{"MEMUSE"} = $string[5];
            $hostsSetup{$host}{"SWAPTO"} = $string[6];
            $hostsSetup{$host}{"SWAPUS"} = $string[7];
         }
      }
   }
   
   return (\%jobsSetup, \%hostsSetup);
}
#
##############################################################################

##############################################################################
# --- create host-config hash
sub getHostsSetup()  {
   my (%hostsSetup, @string, $host);
   my @configDump = split(/\n/,`qhost`);

   # --- skip header and global host
   for (my $i=3; $i < @configDump; $i++)  {
      @string = split(/\s+/,$configDump[$i]);
      $host = $string[0];
      $hostsSetup{$host}{"ARCH"}   = $string[1];
      $hostsSetup{$host}{"NCPU"}   = $string[2];
      $hostsSetup{$host}{"LOAD"}   = $string[3];
      $hostsSetup{$host}{"MEMTOT"} = $string[4];
      $hostsSetup{$host}{"MEMUSE"} = $string[5];
      $hostsSetup{$host}{"SWAPTO"} = $string[6];
      $hostsSetup{$host}{"SWAPUS"} = $string[7];
   }
   
   return \%hostsSetup;
}
#
##############################################################################

##############################################################################
# --- filter jobs to serial and parallel
sub split2SeqParJobs($)  {
   my $jobsIn = shift;
   my (%jobsOut, $type);
   
   foreach my $jobID (keys %{$jobsIn})  {
      $type = (exists $jobsIn->{$jobID}{"Requested PE:"}) ? "parallel" 
                                                          : "serial";
      # --- Here comes CM-specific part
      if (exists $jobsIn->{$jobID}{"Hard Resources:"} && $type eq "serial")  {
         if ($jobsIn->{$jobID}{"Hard Resources:"} =~ /entire/)  {
            $type = "parallel";
         }
      }
      $jobsOut{$type}{$jobID} = $jobsIn->{$jobID};
   }

   return \%jobsOut;
}
#
##############################################################################

##############################################################################
# --- convert memory consumption to human-readable format
sub toKb($)  {
   my $size = shift;
   my $dimensions;
  
   $size =~ m/(\d+.\d*)(\D)/; 
   $size = $1; $dimensions = $2;
   for ($dimensions)  {
      if (/K/)  { $size *= 1 }
      if (/M/)  { $size *= 1024 }
      if (/G/)  { $size *= 1024 * 1024 }
   }
   return $size;
}
#
##############################################################################

##############################################################################
# --- convert memory consumption to human-readable format
sub toGb($)  {
   my $size = shift;
   my $dimensions;
  
   $size =~ m/(\d+.\d*)(\D)/; 
   $size = $1; $dimensions = $2;
   for ($dimensions)  {
      if (/K/)  { $size /= (1024 * 1024) }
      if (/M/)  { $size /= 1024 }
      if (/G/)  { $size *= 1 }
   }
   return $size;
}
#
##############################################################################

##############################################################################
# --- convert time to human-readable format
sub toSec($)  {
   my $timeIn = shift;
   my $timeOut;
   if ($timeIn =~ /\:/)  { # time given in [h:m:s] format and not in [sec]
      my @hms;
      @hms  = split(/\:/,$timeIn);
      $timeOut = $hms[0]*3600 + $hms[1]*60 + $hms[2];
   }  else  {
      $timeOut = $timeIn;
   }
   return $timeOut;
}
#
##############################################################################

##############################################################################
# --- filter jobs to running and waiting
sub filterJobs($$)  {
   my $jobsType  = shift;
   my $jobsSetup = shift;
   my %jobs; my $jobsOut;

   foreach my $jobID (keys %{$jobsSetup})  {
      if (exists $jobsSetup->{$jobID}{"Master Queue:"} ||
          exists $jobsSetup->{$jobID}{"Master queue:"})  {
         $jobs{"running"}{$jobID} = $jobsSetup->{$jobID}     
      }  else  {
         $jobs{"waiting"}{$jobID} = $jobsSetup->{$jobID}
      } 
   }

   for ($jobsType)  {
      if    (/all/)      { $jobsOut = \%jobs }
      elsif (/running/)  { $jobsOut = \%{$jobs{"running"}}}
      elsif (/waiting/)  { $jobsOut = \%{$jobs{"waiting"}}}
   }

   return $jobsOut;
}
#
##############################################################################

##############################################################################
# --- create jobs-hash
sub getComplexSetup()  {

   my (%complexSetup, $complex, @string);
   my @configDump = split(/\n/,`qconf -sc`);
   
   # --- start with 2 to skip header
   for (my $i=2; $i < @configDump - 1; $i++)  {
      @string  = split(/\s+/, $configDump[$i]);
      $complex = $string[0];
      # hardwired layout from qstat
      $complexSetup{$complex}{"shortcut"}    = $string[1];
      $complexSetup{$complex}{"type"}        = $string[2];
      $complexSetup{$complex}{"relop"}       = $string[3];
      $complexSetup{$complex}{"requestable"} = $string[4];
      $complexSetup{$complex}{"consumable"}  = $string[5];
      $complexSetup{$complex}{"default"}     = $string[6];
      $complexSetup{$complex}{"urgency"}     = $string[7];
   }

   return \%complexSetup;
}
#
##############################################################################

##############################################################################
# --- create jobs-hash
sub getJobsSetup($)  {

   my $usersList = shift;

   my (%jobsSetup, $jobID, $param, @string);
#   my @configDump = split(/\n/,`qstat -r -u $allUsers`);
   my @configDump = split(/\n/,`qstat -r $usersList`);

   # --- start with 2 to skip header
   $jobID = 0;
   for (my $i=2; $i < @configDump; $i++)  {
      for ($configDump[$i])  {
         if (/\s?(\d+)\s+(\d+\.\d+\s+.+)/)  {
            $jobID  = $1;
            @string = split(/\s+/,$2);
            # hardwired layout from qstat
            $jobsSetup{$jobID}{"priority"} = $string[0];
            $jobsSetup{$jobID}{"user"}     = $string[2];
            $jobsSetup{$jobID}{"state"}    = $string[3];
            $jobsSetup{$jobID}{"date"}     = $string[4];
            $jobsSetup{$jobID}{"time"}     = $string[5];
            if (@string == 8)  {
               if ($string[6] =~ /(.+)\@(\w+)\..*/)  {
                  $jobsSetup{$jobID}{"queue"} = $1;
                  $jobsSetup{$jobID}{"host"}  = $2;
               }  else  {
                  $jobsSetup{$jobID}{"queue"} = "undef";
                  $jobsSetup{$jobID}{"host"}  = "undef";
               }
               $jobsSetup{$jobID}{"slots"} = $string[7];
            }  else  {                                                       
               $jobsSetup{$jobID}{"queue"} = "undef";
               $jobsSetup{$jobID}{"host"}  = "undef";
               $jobsSetup{$jobID}{"slots"} = $string[6];
            }
         }
         elsif (/\s*([A-Z].+:)\s+(\w+.+)/)  {
            $param = $1;
            $jobsSetup{$jobID}{$param} = $2;
         }
         elsif (/\s*([A-Z].+:)/)  {
            $param = $1;
            $jobsSetup{$jobID}{$param}.= "";
         } 
         elsif (/\s*(\s.+)/)  {
            $jobsSetup{$jobID}{$param}.= $1;
         }  
      }  
   }
   return \%jobsSetup;
}
#
##############################################################################

##############################################################################
#
#  Need this function because the qeueue should be chosen implicitly, i.e.
#  `qsub -q queue_name ...` format is not sufficient (see explanations for
#  sub getQueueName() ). Here, create the map of the 
#  forced-complex-attribute <-> internal-queue-name  
#
sub getQueueAttributeMap($)  {
   my $queuesSetup = shift;
   
   my %queueAttributeMap; my @queueComplex;
   foreach my $queue (keys %$queuesSetup)  {
      # -- create map between system queue names and forced complex
      #    attributes. It is assumed here that the system queue name 
      #    consists of the forced attribute name + some differences, e.g.: 
      #    the attribute name    = cmexpress
      #    the system queue name = cmexpress-entire-node
      @queueComplex = split(/,/, $queuesSetup->{$queue}{"complex_values"});
   a: for (my $i=0; $i < @queueComplex; $i++)  {
         $queueComplex[$i] =~ s/=TRUE//;
         if ($queue =~ /$queueComplex[$i](\S+)?/ && 
             $queue ne "cmdft" && 
             $queue ne "cmopt" &&
             $queue ne "cmduco")  {
            $queueAttributeMap{$queueComplex[$i]} = $queue;
            last a; 
         }
      }
   }

   return (\%queueAttributeMap);
}
#
##############################################################################

##############################################################################
#
#  Need this function because the qeueue should be chosen implicitly, i.e.
#  `qsub -q queue_name ...` format is not sufficient. The queue is chosen 
#  implicitly with `qsub -l attribute_name ...`, where attribute_name is 
#  the "forced compex attribute" that is assigned to each queue. The queue
#  names can have different names from that of the requested attributes.
#  Thus, have to check if the requested attribute exists at all, and if so,
#  to which queue it is assigned
#
sub getQueueName($$)  {
   my $job               = shift;
   my $queueAttributeMap = shift;

   return ($job->{"queue"},$job->{"queue"});	


   my $systemQueueName = "---"; # means unknown queue
   my $userQueueName   = "---"; # means unknown queue
   
a: foreach my $attribute (keys %$queueAttributeMap)  {
   if (exists $job->{"Hard Resources:"})  {

      if ($job->{"Hard Resources:"} =~ /$attribute/)  {
         $systemQueueName = $queueAttributeMap->{$attribute};
         $userQueueName   = $attribute;
# --- Here comes CM-specific part, that adds special symbol in front of
#     the queue name if the forced attribute "entire" is requested
         if ($job->{"Hard Resources:"} =~ /entire=TRUE/)  {
            $userQueueName   = "*" . $userQueueName;
         }
         last a;
       }
     }
   }

   return ($userQueueName, $systemQueueName);
}
#
##############################################################################
